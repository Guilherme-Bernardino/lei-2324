# Object-Oriented Programming 2022/2023

## Lab Sheet #2

### Objective

> - Introduction to the use of unit testing.

## Program

Prototype of an application to facilitate the management of a real estate company. The application must allow to register: the clients, the sellers, the commercialized properties and the sales made by the real estate company (the several registers cannot accept duplicates).

## Implementation rules

- Accept the GitHub Classroom assignent [**here**](https://classroom.github.com/a/Fc7185QA)
- Clone the repository generated by GitHub Classroom
- Use the BlueJ IDE.
- Implement the required code and test at the end of each level.
- **Update the program version in the repository at the minimum at the end of each level** (it is advised at the end of each successfully implemented and tested feature). It is not necessary to include the compiled files (.class extension) in the version.
- Use the coding conventions adopted for the Java language (see **Notes**).

## Implementation

### Level 1:

The supplied classes correspond to the structure of the application classes, with the public method signatures, without the internal code implementation. We will prepare the program so that it can compile, and we will create some basic tests that will be run repeatedly throughout the implementation of the internal code of the application.

1. include all classes provided with this statement `User`, `Property`, `Sell` and `Company` in a BlueJ project from this lab, in the local repository created with GitHub Desktop.
2. Change the methods to return fixed values so that the classes can be compiled. For example, methods that return object references return the value `null`, methods that return integers return the value -1, and so on.

The class `Property` represents a property. Create the test class `PropertyTest`, for the class `Property`.

1. Create the test method `testConstructor` that tests the constructor. This test method should create the property1 object (see data in **Table 1**) as a Fixture and verify that the object is created with the given values, using the price and model selectors to do so.
2. Implement the internal code for the constructor and also for all the selectors of the class (necessary to verify that the constructor has initialized the object with the correct values).
3. Execute the created test (when you complete the internal implementation of all the methods used by the test, it should succeed).
4. When the test passes successfully, create a new version of the application

| Identificador | Modelo | Preço |
|:-------------:|:--------------:|:-------:|
| **property1** | T3 Monte Belo | 150000.0 |

<strong>Table 1</strong> - Property to create for the constructor test

### Level 2:

The method `toString` of the class `Property` must return a string in the format presented in the table 1

1. Create the test method `testToString`.
2. Implement the internal code of the method `toString`.
3. Execute all the created tests.

```shell
Propriedade:
Modelo : T3 Monte Belo
Preço : 150000.0 Euros
```

<strong>List 1</strong> - String example to return by the method toString for the property in the table 1

### Level 3:

The `Company` class represents a real estate company.

| Identifier | Name | Phone | E-mail |
|:-------------:|:----------------:|:---------:|:-------------------------:|
| **client1** | José Manuel | 911111111 | zemanel@yahoo.com |
| **client2** | António Francisco | 922222222 | tochico@hotmail.com |
| **seller1** | Fernando Fernandes | 966777101 | fefe@remax.pt |
| **seller2** | Rodrigo Rodrigues | 966777152 | roro@remax.pt |
<strong>Table 2</strong> - Fixture objects for the class CompanyTest

1. Create the test class `CompanyTest`, for the `Company` class.
2. Define in the `CompanyTest` class a Fixture with a `Company` object and all the objects in table 2. Use the existing `setUp()` method for this purpose.
3. Create, in this class, the test method `testConstructor` that tests the constructor. This test method creates verifies that the constructor instantiates the real estate collections configured in the `setUp()` method, that is, that after creation the attributes are not null.
4. Implement the internal code for the constructor and the selectors of the class.
5. Run all the created tests.
   
### Level 4:

1. Create the unit test `testRegisterClient` that registers one client and the test method `testRegisterClients` that registers two clients.

2. Create the `testRegisterClientDuplicate` unit test, which validates that you cannot register the same client twice.

3. Create the `testRegisterClientNull` unit test, which attempts to register a null client.

4. Then implement the internal code for the `registerClient` method.

5. Run all the created tests.

6. Apply the same approach 

### Level 5:

1. Define a Fixture that creates the sell1 object (see data in **Table 3**).
   
| Identifier | Name | Phone | E-mail |
|:-------------:|:-------:|:--------:|:--------:|
| **sell1** | client1 | seller1 | property1 |
| **sell2** | client2 | seller2 | property2 |

<strong>Table 3</strong> - Sales to be created.

1. Create in the **PropertyTest** test class the `testCreateSell` test method.

2. Then implement the internal code for the `createSell` method.

3. Execute all the created tests.

4. Create the test method `testCalculateSellsOfTheYear`. Then implement the code inside the `calculateSellsOfTheYear` method.
   
5. Run all the created tests.

6. Create the test method `testFindSellerOfTheYear`. Then implement the inner code of the `findSellerOfTheYear` method.

7. Run all the created tests.

## **Notes:**

For identifiers follow the conventions adopted normally, in particular:

1. The **camelCase** notation for the name of local variables and identifiers for attributes and methods.

2. The **PascalCase** notation for class names.

3. Do not use the '_' symbol or abbreviations for identifiers.
